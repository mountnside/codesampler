//-----------------------------------------------------------------------------
//           Name: stl_deque.cpp
//         Author: Kevin Harris
//  Last Modified: 09/25/04
//    Description: This sample demonstrates how to use STL's deque container 
//                 (pronounced like 'deck') to store a sequence of char values. 
//                 The sequence is stored as a double-ended queue, which 
//                 permits the insertion and removal of an element at either 
//                 end.
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>

using namespace std;

//
// First, let us create a new type, which represents a deque container of chars.
// This step is not really necessary, but it helps to keep our code from 
// becoming too cluttered.
//

typedef deque< char > myDequeType;

void printContents( myDequeType deque );

void main( void )
{
    //
    // Create the initial deque and load it with some char values to work with.
    // Once that's done, print out the contents for inspection.
    //

    myDequeType myDeque;

    myDeque.push_back( 'A' );
    myDeque.push_back( 'B' );
    myDeque.push_back( 'C' );
    myDeque.push_back( 'D' );

    printContents( myDeque );

    //
    // Now, let's modify the first and last elements of the deque using 
    // references generated by calls to front() and back().
    //

    myDequeType::reference ref_front = myDeque.front();
    myDequeType::reference ref_back  = myDeque.back();

    ref_front = 'a'; // Change the first element from A to a
    ref_back  = 'd'; // Change the last element from D to d

    printContents( myDeque );

    //
    // Ok, let's change them back but this time we'll use iterators instead 
    // reference pointers.
    //
    // Note how we dereference the iterators with * when setting them.
    //

    myDequeType::iterator it_begin = myDeque.begin();
    myDequeType::iterator it_end   = myDeque.end();

    *it_begin = 'A'; // Change the first element from a to back to A

    --it_end;
    *it_end   = 'D'; // Change the last element from d to back to D

    //
    // Whoa...hang on! What's that decrement for?
    //
    // The line above that says "--it_end;" is important because it_end points 
    // to a position which is one past the last element.
    //
    // And since it doesn't point at the last element of myDeque, we have to 
    // move it back one position by decrementing it. This will make it actually 
    // point to the last element like we want.
    //

    printContents( myDeque );

    //
    // Now, since it's a double-ended queue we can add elements by pushing
    // them on to the front of the queue or the back like so:
    //

    myDeque.push_front( '1' );
    myDeque.push_back( '9' );

    printContents( myDeque );

    //
    // And if you can push elements on, you can also pop them back off like so:
    //

    myDeque.pop_front();
    myDeque.pop_back();

    printContents( myDeque );

    //
    // Of course, if we keep popping the queue, we'll end up with nothing...
    //

    myDeque.pop_front();
    myDeque.pop_back();

    printContents( myDeque );

    myDeque.pop_front();
    myDeque.pop_back();

    printContents( myDeque );

}

void printContents( myDequeType deque )
{
    //
    // Using iterators, which point to the beginning and ending of the vector,  
    // we can loop through the vector and print out its contents.
    //

    myDequeType::iterator it_begin = deque.begin();
    myDequeType::iterator it_end   = deque.end();

    cout << "Contents of myDeque: ";

    for( /*empty*/; it_begin != it_end; ++it_begin )
    {
        cout << *it_begin << " " ;
    }

    cout << endl;
}

