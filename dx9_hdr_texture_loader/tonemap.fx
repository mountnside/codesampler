//------------------------------------------------------------------------------
//           Name: tonemap.fx
//         Author: Kevin Harris
//  Last Modified: 04/14/05
//    Description: Vertex & Pixel shader for tone-mapping fragment colors 
//                 generated by the HDR texture. This .fx file is based on a
//                 nVIDIA effect which ships with FX Composer 1.6.
//
// Even though we now have access to a high-dynamic image, we still must deal 
// with low-dynamic display devices like CRTs and LCD panels. One way to do this
// is called, "Tone Mapping", which uses an exposure level to restrict 
// the high-dynamic image for usage on a low-dynamic device. 
//
// This is similar to how the human eye works. Your eye has considerable range, 
// but it can't see the whole range at one time. It takes time for it to adjust
// as the environment changes. For example, if you walk out of a dark room and 
// into the broad daylight, you'll be blinded for a moment as your eyes adjust 
// to the bright light. After a few moments, your eyes have adjusted from seeing 
// well in the dark to seeing well in the light.
//------------------------------------------------------------------------------

float exposureLevel;
float gammaLevel;
float deFogLevel;

float3 fogColor = { 1.0, 1.0, 1.0 };
float4x4 worldViewProj : WorldViewProjection;

texture hdrTexture;
sampler HDRSampler = sampler_state
{
    Texture = ( hdrTexture );
    MinFilter = Linear;
	MagFilter = Linear;
	MipFilter = None;
};

struct VS_IN 
{
    float4 position : POSITION;
    float4 texcoord : TEXCOORD0;
};

struct VS_OUT 
{
    float4 hposition : POSITION;
    float4 texcoord  : TEXCOORD0;
    float  exposure  : TEXCOORD1;
};

struct PS_OUT
{
	float4 color : COLOR;
};

VS_OUT toneMapVS( VS_IN IN )
{
	VS_OUT OUT;
	
	OUT.hposition = mul( worldViewProj, IN.position );
	OUT.texcoord = IN.texcoord;
	OUT.exposure = pow( 2.0, exposureLevel );

    return OUT;
}

PS_OUT toneMapPS( VS_OUT IN )
{
    PS_OUT OUT;

    half3 hdrTexelColor = tex2D( HDRSampler, IN.texcoord );
    
    // Apply de-fogging
	hdrTexelColor = max( 0, hdrTexelColor - (deFogLevel * fogColor) );
	
	// Apply expsosure
    hdrTexelColor *= IN.exposure;
    
    // Apply gamma correction (you could use a texture lookups for this)
	hdrTexelColor = pow( hdrTexelColor, gammaLevel );
    OUT.color = half4( hdrTexelColor.rgb, 1.0 );

    return OUT;
}

technique Technique0
{
    pass Pass0
    {
        Sampler[0]  = ( HDRSampler );

        VertexShader = compile vs_1_1 toneMapVS();
        PixelShader  = compile ps_2_0 toneMapPS();
    }
}