//------------------------------------------------------------------------------
//           Name: dx9_hdr_texture_loader.cpp
//         Author: Kevin Harris
//  Last Modified: 04/14/05
//    Description: This sample demonstrates how to load a .hdr or "light probe"
//                 image file (High Dynamic Range) as a Dirct3D texture.
//
//                 The sample also demonstrates how to use a vertex and pixel 
//                 shader to perform tone-mapping on the fragment colors 
//                 generated by the HDR texture, so they can they can be 
//                 rendered on low-dynamic display devices like CRTs and 
//                 LCD panels.
//
//                 The .hdr file format was developed by Paul Debevec.
//                 http://www.debevec.org/
//
//                 The files, "rgbe.h" and "rgbe.cpp" were written by 
//                 Bruce Walter.
//                 http://www.graphics.cornell.edu/%7Ebjw/rgbe.html.
//                 These two files make it considerably easier to work with the 
//                 Radiance RGBE image format, which was invented by 
//                 Greg Ward.
//                 http://www.anyhere.com/gward/hdrenc/hdr_encodings.html
//
//                 The HDR imaage file, "rend13_o7B0.hdr" was also downloaded 
//                 from Greg Ward's site:
//                 http://www.anyhere.com/gward/hdrenc/pages/originals.html
//
//                 I would also like the thank, Anirudh S. Shastry, for his 
//                 excellent article on GameDev, which was very helpful in 
//                 creating this sample.
//                 http://www.gamedev.net/reference/articles/article2108.asp
//
//   Control Keys: Left Mouse Button - Spin the quad
//                 e - Increase Exposure Level
//                 E - Decrease Exposure Level
//                 g - Increase Gamma Level
//                 G - Decrease Gamma Level
//                 d - Increase De-Fog Level
//                 D - Decrease De-Fog  Level
//------------------------------------------------------------------------------

#define STRICT
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <stdio.h>
#include <d3d9.h>
#include <d3dx9.h>
#include "resource.h"
#include "rgbe.h"

//-----------------------------------------------------------------------------
// GLOBALS
//-----------------------------------------------------------------------------
HWND              g_hWnd       = NULL;
LPDIRECT3D9       g_pD3D       = NULL;
LPDIRECT3DDEVICE9 g_pd3dDevice = NULL;

LPDIRECT3DVERTEXBUFFER9 g_pQuadVertexBuffer = NULL;
LPDIRECT3DTEXTURE9      g_pHDRTexture       = NULL;
LPD3DXEFFECT            g_pExposureFx       = NULL;

float g_fExposureLevel = 1.0f;
float g_fGamaLevel     = 0.5f;
float g_fDeFogLevel    = 0.0f;

D3DXMATRIX g_matWorld;
D3DXMATRIX g_matView;
D3DXMATRIX g_matProj;

float g_fSpinX = 0.0f;
float g_fSpinY = 0.0f;

struct Vertex
{
    float x, y, z;
    float tu, tv;

    enum FVF
    {
        FVF_Flags = D3DFVF_XYZ | D3DFVF_TEX1
    };
};

Vertex g_quadVertices[] =
{
	{-1.0f, 1.0f, 0.0f,  0.0f,0.0f },
	{ 1.0f, 1.0f, 0.0f,  1.0f,0.0f },
	{-1.0f,-1.0f, 0.0f,  0.0f,1.0f },
	{ 1.0f,-1.0f, 0.0f,  1.0f,1.0f }
};

//------------------------------------------------------------------------------
// PROTOTYPES
//------------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
                   LPSTR lpCmdLine, int nCmdShow);
LRESULT CALLBACK WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
void init(void);
void loadHDRTexture( void );
void shutDown(void);
void render(void);

//------------------------------------------------------------------------------
// Name: WinMain()
// Desc: The application's entry point
//------------------------------------------------------------------------------
int WINAPI WinMain( HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     lpCmdLine,
                    int       nCmdShow )
{
	WNDCLASSEX winClass; 
	MSG        uMsg;

    memset(&uMsg,0,sizeof(uMsg));

	winClass.lpszClassName = "MY_WINDOWS_CLASS";
	winClass.cbSize        = sizeof(WNDCLASSEX);
	winClass.style         = CS_HREDRAW | CS_VREDRAW;
	winClass.lpfnWndProc   = WindowProc;
	winClass.hInstance     = hInstance;
	winClass.hIcon	       = LoadIcon(hInstance, (LPCTSTR)IDI_DIRECTX_ICON);
    winClass.hIconSm	   = LoadIcon(hInstance, (LPCTSTR)IDI_DIRECTX_ICON);
	winClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
	winClass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
	winClass.lpszMenuName  = NULL;
	winClass.cbClsExtra    = 0;
	winClass.cbWndExtra    = 0;

	if( !RegisterClassEx(&winClass) )
		return E_FAIL;

    g_hWnd = CreateWindowEx( NULL, "MY_WINDOWS_CLASS", 
                            "Direct3D (DX9) - High Dynamic Range Texture Loader",
						    WS_OVERLAPPEDWINDOW | WS_VISIBLE,
					        0, 0, 640, 480, NULL, NULL, hInstance, NULL );

	if( g_hWnd == NULL )
		return E_FAIL;

    ShowWindow( g_hWnd, nCmdShow );
    UpdateWindow( g_hWnd );

    init();

	while( uMsg.message != WM_QUIT )
	{
		if( PeekMessage( &uMsg, NULL, 0, 0, PM_REMOVE ) )
		{
			TranslateMessage( &uMsg );
			DispatchMessage( &uMsg );
		}
		else
		    render();
	}

    shutDown();

    UnregisterClass( "MY_WINDOWS_CLASS", winClass.hInstance );

    return uMsg.wParam;
}

//------------------------------------------------------------------------------
// Name: WindowProc()
// Desc: The window's message handler
//------------------------------------------------------------------------------
LRESULT CALLBACK WindowProc( HWND   hWnd, 
                             UINT   msg, 
                             WPARAM wParam, 
                             LPARAM lParam )
{
    static POINT ptLastMousePosit;
    static POINT ptCurrentMousePosit;
    static bool bMousing;

    switch( msg )
    {
        case WM_CHAR:
        {
            switch( wParam )
            {
                case 'e':
                    g_fExposureLevel += 0.1f;
                    break;

                 case 'E':
                    g_fExposureLevel -= 0.1f;
                    break;

				 case 'g':
					 g_fGamaLevel += 0.01f;
					 break;

				 case 'G':
					 g_fGamaLevel -= 0.01f;
					 break;

				 case 'd':
					 g_fDeFogLevel += 0.001;
					 break;

				 case 'D':
					 g_fDeFogLevel -= 0.001;
					 break;
            }
        }
        break;

        case WM_KEYDOWN:
        {
            switch( wParam )
            {
                case VK_ESCAPE:
                    PostQuitMessage(0);
                    break;
            }
        }
        break;

        case WM_LBUTTONDOWN:
        {
            ptLastMousePosit.x = ptCurrentMousePosit.x = LOWORD (lParam);
            ptLastMousePosit.y = ptCurrentMousePosit.y = HIWORD (lParam);
            bMousing = true;
        }
        break;

        case WM_LBUTTONUP:
        {
            bMousing = false;
        }
        break;

        case WM_MOUSEMOVE:
        {
            ptCurrentMousePosit.x = LOWORD (lParam);
            ptCurrentMousePosit.y = HIWORD (lParam);

            if( bMousing )
            {
                g_fSpinX -= (ptCurrentMousePosit.x - ptLastMousePosit.x);
                g_fSpinY -= (ptCurrentMousePosit.y - ptLastMousePosit.y);
            }
            
            ptLastMousePosit.x = ptCurrentMousePosit.x;
            ptLastMousePosit.y = ptCurrentMousePosit.y;
        }
        break;
        
        case WM_CLOSE:
        {
            PostQuitMessage(0); 
        }
        break;

        case WM_DESTROY:
        {
            PostQuitMessage(0);
        }
        break;
        
        default:
        {
            return DefWindowProc( hWnd, msg, wParam, lParam );
        }
        break;
    }

    return 0;
}

//------------------------------------------------------------------------------
// Name: init()
// Desc: 
//------------------------------------------------------------------------------
void init( void )
{
    g_pD3D = Direct3DCreate9( D3D_SDK_VERSION );

    D3DDISPLAYMODE d3ddm;

    g_pD3D->GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &d3ddm );

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory( &d3dpp, sizeof(d3dpp) );

    d3dpp.Windowed               = TRUE;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
    d3dpp.BackBufferFormat       = d3ddm.Format;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
    d3dpp.PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;

    g_pD3D->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, g_hWnd,
                          D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                          &d3dpp, &g_pd3dDevice );

    g_pd3dDevice->CreateVertexBuffer( 4 * sizeof(Vertex),0, Vertex::FVF_Flags,
                                      D3DPOOL_DEFAULT, &g_pQuadVertexBuffer, NULL );
    void *pVertices = NULL;

    g_pQuadVertexBuffer->Lock( 0, sizeof(g_quadVertices), (void**)&pVertices, 0 );
    memcpy( pVertices, g_quadVertices, sizeof(g_quadVertices) );
    g_pQuadVertexBuffer->Unlock();

    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    D3DXMatrixPerspectiveFovLH( &g_matProj, D3DXToRadian( 45.0f ), 
                            640.0f / 480.0f, 0.1f, 100.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &g_matProj );

    //
    // Load up the .fx file that controls the exposure level...
    //

    LPD3DXBUFFER pBuffer;

    if( FAILED( D3DXCreateEffectFromFile( g_pd3dDevice, "tonemap.fx", NULL, NULL, 
                                          0, NULL, &g_pExposureFx, &pBuffer ) ) )
    {
        LPVOID pCompileErrors = pBuffer->GetBufferPointer();
        MessageBox(NULL, (const char*)pCompileErrors, "Compile Error",
            MB_OK|MB_ICONEXCLAMATION);
    }

    loadHDRTexture();
}

//------------------------------------------------------------------------------
// Name: loadHDRTexture()
// Desc: 
//------------------------------------------------------------------------------
void loadHDRTexture( void )
{
    //
    // Open the HDR image or "light probe" file and read the header.
    //

    FILE* pFile = fopen( "rend13_o7B0.hdr", "rb" );

    rgbe_header_info rgbeHeader;
    int nHDRImageWidth  = 0;
    int nHDRImageHeight = 0;

    RGBE_ReadHeader( pFile, &nHDRImageWidth, &nHDRImageHeight, &rgbeHeader );

    // These always seem to be set to 1.0f and 1.0f, so I don't know what 
    // they're good for. Maybe they mean something for other .hdr images.
    float fExposure = rgbeHeader.exposure;
    float fGamma    = rgbeHeader.gamma;

    //
    // Create a float array and read in the RGB components.
    //

    int nTotalHDRImageSize = 3 * nHDRImageWidth * nHDRImageHeight;

    float* pPixelsFromHDRFile = new float[ nTotalHDRImageSize ];
    memset( pPixelsFromHDRFile, 0, nTotalHDRImageSize*sizeof(float) );

    RGBE_ReadPixels_RLE( pFile, pPixelsFromHDRFile, nHDRImageWidth, nHDRImageHeight );

    //
    // Copy over the HDR image data into an array suitable for loading into a
    // Direct3D texture.
    //
    // Note: Since we're using the 64-bit surface format D3DFMT_A16B16G16R16F 
    //       we need convert the 32-bit floats read from the .hdr file into into 
    //       16-bit floats. To do this, allocate a new array using "D3DXFLOAT16" 
    //       instead of "float".
    //

    int nTotalHDRTextureSize = 4 * nHDRImageWidth * nHDRImageHeight;
    D3DXFLOAT16* pPixelsForHDRTexture = new D3DXFLOAT16[ nTotalHDRTextureSize ];

    for( int i = 0, j = 0; i < nTotalHDRTextureSize; i += 4, j += 3 )
    {
        pPixelsForHDRTexture[ i ] = pPixelsFromHDRFile[ j ]; // Copy over R
        pPixelsForHDRTexture[i+1] = pPixelsFromHDRFile[j+1]; // Copy over G
        pPixelsForHDRTexture[i+2] = pPixelsFromHDRFile[j+2]; // Copy over B

        // The HDR image doens't have alpha. Just set all alpha values to 0.0f
        pPixelsForHDRTexture[i+3] = 0.0f;
    }

    //
    // Create a Direct3D texture object and load the converted HDR image data 
    // into it.
    //

    if( FAILED( D3DXCreateTexture( g_pd3dDevice, nHDRImageWidth, nHDRImageHeight, 
                                   1, D3DUSAGE_DYNAMIC, D3DFMT_A16B16G16R16F,
                                   D3DPOOL_DEFAULT, &g_pHDRTexture ) ) )
    {
        MessageBox( g_hWnd, "Call to D3DXCreateTexture failed! "
            "Unable to create a texture object suitable for a HDR texture.",
            "Error", MB_OK|MB_ICONEXCLAMATION );
    }

    D3DLOCKED_RECT lockedRect;
    g_pHDRTexture->LockRect( 0, &lockedRect, NULL, 0 );
    {
        memcpy( (D3DXFLOAT16*)lockedRect.pBits, pPixelsForHDRTexture, 
                nTotalHDRTextureSize*sizeof(D3DXFLOAT16) );
    }
    g_pHDRTexture->UnlockRect( 0 );

    delete[] pPixelsFromHDRFile;
    delete[] pPixelsForHDRTexture;
    fclose( pFile );
}

//------------------------------------------------------------------------------
// Name: shutDown()
// Desc: Releases all previously initialized objects
//------------------------------------------------------------------------------
void shutDown( void )
{
    if( g_pHDRTexture != NULL )
        g_pHDRTexture->Release();

    if( g_pQuadVertexBuffer != NULL )
        g_pQuadVertexBuffer->Release();

    if( g_pExposureFx != NULL )
        g_pExposureFx->Release();

    if( g_pd3dDevice != NULL )
        g_pd3dDevice->Release();

    if( g_pD3D != NULL )
        g_pD3D->Release();
}

//------------------------------------------------------------------------------
// Name: render()
// Desc: Draws the scene
//------------------------------------------------------------------------------
void render( void )
{
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
                         D3DCOLOR_COLORVALUE( 0.35f, 0.53f, 0.7, 1.0f ), 1.0f, 0 );

	g_pd3dDevice->BeginScene();

    D3DXMATRIX matTrans;
    D3DXMATRIX matRot;

    D3DXMatrixTranslation( &matTrans, 0.0f, 0.0f, 3.0f );
    D3DXMatrixRotationYawPitchRoll( &matRot,
                                    D3DXToRadian(g_fSpinX),
                                    D3DXToRadian(g_fSpinY),
                                    0.0f );
    g_matWorld = matRot * matTrans;
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &g_matWorld );

    D3DXMatrixIdentity( &g_matView ); // This sample is not really making use of a view matrix
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &g_matView );

    //
    // Setup the effect parameters and render our HDR textured quad...
    //

    g_pExposureFx->SetTechnique( "Technique0" );

	D3DXMATRIX worldViewProjection = g_matWorld * g_matView * g_matProj;
	D3DXMatrixTranspose( &worldViewProjection, &worldViewProjection );
	g_pExposureFx->SetMatrix( "worldViewProj", &worldViewProjection );

    g_pExposureFx->SetTexture( "hdrTexture", g_pHDRTexture );
    g_pExposureFx->SetFloat( "exposureLevel", g_fExposureLevel );
	g_pExposureFx->SetFloat( "gammaLevel", g_fGamaLevel );
	g_pExposureFx->SetFloat( "deFogLevel", g_fDeFogLevel );

    UINT uPasses;
    g_pExposureFx->Begin( &uPasses, 0 );
    {
        for( UINT uPass = 0; uPass < uPasses; ++uPass )
        {
            g_pExposureFx->BeginPass( uPass );
            {
                g_pd3dDevice->SetStreamSource( 0, g_pQuadVertexBuffer, 0, sizeof( Vertex ) );
                g_pd3dDevice->SetFVF( Vertex::FVF_Flags );
                g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
            }
            g_pExposureFx->EndPass();
        }
    }
    g_pExposureFx->End();

    g_pd3dDevice->EndScene();

    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}
